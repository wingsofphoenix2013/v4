# laboratory_pack_live.py ‚Äî –≤–æ—Ä–∫–µ—Ä laboratory_v4: PACK (rsi/mfi/ema/atr/lr/adx_dmi/macd/bb) —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º live-–∫–µ—à–∞ IND; –ø—É–±–ª–∏–∫–∞—Ü–∏—è –≤ lab_live:pack:...

# üî∏ –ò–º–ø–æ—Ä—Ç—ã
import asyncio
import logging
import time
import json
from typing import Tuple, Dict, List, Set

from lab_utils import floor_to_bar
from compute_only import compute_snapshot_values_async  # fallback-—Ä–∞—Å—á—ë—Ç live –ø—Ä–∏ –ø—Ä–æ–º–∞—Ö–µ –∫–µ—à–∞
from laboratory_config import get_live_values           # —á—Ç–µ–Ω–∏–µ live –∏–∑ in-memory –∫–µ—à–∞ IND

# üî∏ –ü–∞–∫–µ—Ç–Ω—ã–µ –±–∏–ª–¥–µ—Ä—ã –±–∞–∑–æ–≤—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ (—Ä–∞–±–æ—Ç–∞—é—Ç –Ω–∞ —Ç–µ–∫—É—â–µ–º –±–∞—Ä–µ)
from packs.rsi_pack import build_rsi_pack
from packs.mfi_pack import build_mfi_pack
from packs.ema_pack import build_ema_pack
from packs.atr_pack import build_atr_pack
from packs.lr_pack import build_lr_pack
from packs.adx_dmi_pack import build_adx_dmi_pack
from packs.macd_pack import build_macd_pack
from packs.bb_pack import build_bb_pack

# üî∏ –õ–æ–≥–≥–µ—Ä
log = logging.getLogger("LAB_PACK_LIVE")

# üî∏ –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –≤–æ—Ä–∫–µ—Ä–∞
TF_SET = ("m5", "m15", "h1")     # –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ TF
LAB_PREFIX = "lab_live"          # –ø—Ä–µ—Ñ–∏–∫—Å –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–∏
LAB_TTL_SEC = 60                 # TTL KV-–∑–∞–ø–∏—Å–µ–π
TICK_INTERVAL_SEC = 15           # –ø–µ—Ä–∏–æ–¥ —Ç–∏–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏
MAX_CONCURRENCY = 64             # –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã–µ –ø–∞—Ä—ã (symbol, tf)
BASE_CONCURRENCY = 16            # –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º –ø–æ –±–∞–∑–∞–º –≤–Ω—É—Ç—Ä–∏ –ø–∞—Ä—ã (rsi14, ema21, macd12, bb20_2_0, ...)

# üî∏ –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ ‚Üí builder –∏ —Ç–∏–ø –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
BUILDERS = {
    "rsi": ("length", build_rsi_pack),
    "mfi": ("length", build_mfi_pack),
    "ema": ("length", build_ema_pack),
    "atr": ("length", build_atr_pack),
    "lr":  ("length", build_lr_pack),
    "adx_dmi": ("length", build_adx_dmi_pack),
    "macd": ("fast", build_macd_pack),
    "bb":  ("bb", build_bb_pack),  # –ø–∞—Ä–∞ (length, std)
}

# üî∏ –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å KV-–∫–ª—é—á –¥–ª—è PACK
def _pack_key(indicator: str, symbol: str, tf: str, base: str) -> str:
    return f"{LAB_PREFIX}:pack:{indicator}:{symbol}:{tf}:{base}"

# üî∏ –°–æ–±—Ä–∞—Ç—å –Ω–∞–±–æ—Ä –±–∞–∑ (base) –ø–æ –∫–µ—à—É –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ TF
def _collect_bases(instances: List[Dict]) -> Dict[str, Set]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
      {
        "rsi": {14, 21, ...},
        "bb": {(20, 2.0), ...},
        "macd": {12, 5, ...},
        ...
      }
    """
    out: Dict[str, Set] = {
        "rsi": set(), "mfi": set(), "ema": set(), "atr": set(), "lr": set(), "adx_dmi": set(),
        "macd": set(), "bb": set()
    }
    for inst in instances:
        kind = inst.get("indicator")
        params = inst.get("params") or {}
        if kind not in out:
            continue
        try:
            if kind in ("rsi", "mfi", "ema", "atr", "lr", "adx_dmi"):
                L = int(params.get("length"))
                out[kind].add(L)
            elif kind == "macd":
                F = int(params.get("fast"))
                out[kind].add(F)
            elif kind == "bb":
                L = int(params.get("length"))
                S = round(float(params.get("std")), 2)
                out[kind].add((L, S))
        except Exception:
            # –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫—Ä–∏–≤—ã–µ ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ—Ç –∏–Ω—Å—Ç–∞–Ω—Å
            continue
    return out

# üî∏ –ü—É–±–ª–∏–∫–∞—Ü–∏—è –æ–¥–Ω–æ–≥–æ PACK –ø–æ–¥ –∫–ª—é—á lab_live:pack:... —Å TTL
async def _persist_pack(redis, indicator: str, symbol: str, tf: str, pack_obj: Dict) -> bool:
    try:
        base = pack_obj.get("base")
        if not base:
            return False
        key = _pack_key(indicator, symbol, tf, base)
        await redis.set(key, json.dumps(pack_obj), ex=LAB_TTL_SEC)
        return True
    except Exception as e:
        log.warning("persist error %s/%s %s base=? : %s", symbol, tf, indicator, e)
        return False

# üî∏ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–π –ø–∞—Ä—ã (symbol, tf): —Å—Ç—Ä–æ–∏–º –≤—Å–µ —Ç—Ä–µ–±—É–µ–º—ã–µ PACK –ø–æ –∞–∫—Ç–∏–≤–Ω—ã–º –∏–Ω—Å—Ç–∞–Ω—Å–∞–º
async def _process_pair(
    redis,
    symbol: str,
    tf: str,
    open_ms: int,
    precision: int,
    instances: List[Dict],
) -> Tuple[int, int]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (published_packs, skipped_packs)
    """
    bases = _collect_bases(instances)
    published = 0
    skipped = 0

    # –æ–±—ë—Ä—Ç–∫–∞ compute_fn: —Å–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å live –∏–∑ –∫–µ—à–∞ IND (–ø–æ (symbol, tf, open_ms)), –ø—Ä–∏ –ø—Ä–æ–º–∞—Ö–µ ‚Äî —Å—á–∏—Ç–∞–µ–º
    async def compute_fn_cached(inst: dict, symbol_: str, df, precision_: int) -> Dict[str, str]:
        try:
            tf_ = inst.get("timeframe")
            if tf_ is None:
                return await compute_snapshot_values_async(inst, symbol_, df, precision_)
            cached = get_live_values(symbol_, tf_, open_ms)
            if not cached:
                return await compute_snapshot_values_async(inst, symbol_, df, precision_)

            indicator = inst.get("indicator")
            params = inst.get("params") or {}
            if indicator == "macd":
                base = f"macd{params['fast']}"
            elif "length" in params:
                base = f"{indicator}{params['length']}"
            else:
                base = str(indicator)

            out: Dict[str, str] = {}
            for k, v in cached.items():
                s = str(k)
                if s == base or s.startswith(f"{base}_"):
                    out[s] = str(v)

            if not out:
                return await compute_snapshot_values_async(inst, symbol_, df, precision_)
            return out
        except Exception:
            return await compute_snapshot_values_async(inst, symbol_, df, precision_)

    # –æ–≥—Ä–∞–Ω–∏—á–∏–º –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º –ø–æ –±–∞–∑–∞–º –ª–æ–∫–∞–ª—å–Ω—ã–º —Å–µ–º–∞—Ñ–æ—Ä–æ–º
    base_sem = asyncio.Semaphore(BASE_CONCURRENCY)

    async def _build_and_publish(ind: str, base_item) -> Tuple[int, int]:
        async with base_sem:
            try:
                which, builder = BUILDERS[ind]
                if which == "length":
                    pack_obj = await builder(symbol, tf, int(base_item), open_ms, precision, redis, compute_fn_cached)
                elif which == "fast":
                    pack_obj = await builder(symbol, tf, int(base_item), open_ms, precision, redis, compute_fn_cached)
                elif which == "bb":
                    L, S = base_item
                    pack_obj = await builder(symbol, tf, int(L), float(S), open_ms, precision, redis, compute_fn_cached)
                else:
                    return (0, 1)

                if not pack_obj:
                    return (0, 1)

                ok = await _persist_pack(redis, ind, symbol, tf, pack_obj)
                return (1 if ok else 0, 0 if ok else 1)
            except Exception as e:
                log.warning("pack build error %s/%s %s %r: %s", symbol, tf, ind, base_item, e)
                return (0, 1)

    # —Å–æ–±–∏—Ä–∞–µ–º –∑–∞–¥–∞—á–∏ –ø–æ –≤—Å–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º –∏ –∏—Ö –±–∞–∑–∞–º
    tasks = []
    for ind, items in bases.items():
        for it in items:
            tasks.append(asyncio.create_task(_build_and_publish(ind, it)))

    if tasks:
        results = await asyncio.gather(*tasks, return_exceptions=False)
        for pub, sk in results:
            published += pub
            skipped += sk

    return (published, skipped)

# üî∏ –û–¥–∏–Ω–æ—á–Ω—ã–π —Ç–∏–∫: –≤—ã–ø–æ–ª–Ω–∏—Ç—å –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –ø–æ —É–∫–∞–∑–∞–Ω–Ω—ã–º TF (–±–µ–∑ –∑–∞–¥–µ—Ä–∂–∫–∏/—Ü–∏–∫–ª–∞)
async def tick_pack(
    pg,
    redis,
    get_active_symbols,      # callable() -> list[str]
    get_precision,           # callable(symbol) -> int|None
    get_instances_by_tf,     # callable(tf) -> list[instance]
    get_last_bar,            # callable(symbol, tf) -> int|None
    tf_set: Tuple[str, ...] = TF_SET,
) -> Tuple[int, int, int, int]:
    """
    –í—ã–ø–æ–ª–Ω–∏—Ç—å –æ–¥–∏–Ω PACK-–ø—Ä–æ—Ö–æ–¥ –ø–æ –≤—Å–µ–º —Å–∏–º–≤–æ–ª–∞–º –∏ tf_set.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–≥—Ä–µ–≥–∞—Ç—ã: (pairs, published_packs, skipped, elapsed_ms).
    """
    t0 = time.monotonic()
    now_ms = int(time.time() * 1000)

    symbols = get_active_symbols()
    if not symbols:
        return (0, 0, 0, int((time.monotonic() - t0) * 1000))

    sem = asyncio.Semaphore(MAX_CONCURRENCY)

    # –∫—ç—à –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤ –ø–æ TF –Ω–∞ —Ç–∏–∫ (–æ–Ω–∏ –æ–±—â–∏–µ –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤)
    inst_by_tf: Dict[str, List[Dict]] = {tf: get_instances_by_tf(tf) for tf in tf_set}

    total_pairs = 0
    total_published = 0
    total_skipped = 0

    async def run_one(sym: str, tf: str):
        nonlocal total_pairs, total_published, total_skipped
        async with sem:
            last = get_last_bar(sym, tf)
            open_ms = last if last is not None else floor_to_bar(now_ms, tf)
            prec = get_precision(sym) or 8
            try:
                pub, sk = await _process_pair(redis, sym, tf, open_ms, prec, inst_by_tf.get(tf, []))
            except Exception as e:
                log.warning("pair error %s/%s: %s", sym, tf, e)
                pub, sk = 0, 0
            total_pairs += 1
            total_published += pub
            total_skipped += sk

    tasks = [
        asyncio.create_task(run_one(sym, tf))
        for sym in symbols
        for tf in tf_set
    ]
    if tasks:
        await asyncio.gather(*tasks, return_exceptions=False)

    elapsed_ms = int((time.monotonic() - t0) * 1000)
    return (total_pairs, total_published, total_skipped, elapsed_ms)

# üî∏ –û—Å–Ω–æ–≤–Ω–æ–π –≤–æ—Ä–∫–µ—Ä (–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä–µ, –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
async def run_lab_pack_live(
    pg,
    redis,
    get_active_symbols,      # callable() -> list[str]
    get_precision,           # callable(symbol) -> int|None
    get_instances_by_tf,     # callable(tf) -> list[instance]
    get_last_bar,            # callable(symbol, tf) -> int|None
    tf_set: Tuple[str, ...] = TF_SET,
    tick_interval_sec: int = TICK_INTERVAL_SEC,
):
    while True:
        pairs, published, skipped, elapsed_ms = await tick_pack(
            pg=pg,
            redis=redis,
            get_active_symbols=get_active_symbols,
            get_precision=get_precision,
            get_instances_by_tf=get_instances_by_tf,
            get_last_bar=get_last_bar,
            tf_set=tf_set,
        )

        log.info(
            "LAB PACK: tick done tf=%s pairs=%d packs=%d skipped=%d elapsed_ms=%d",
            ",".join(tf_set), total_pairs, total_published, total_skipped, elapsed_ms
        )

        await asyncio.sleep(tick_interval_sec)