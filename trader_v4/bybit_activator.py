# bybit_activator.py ‚Äî –∞–∫—Ç–∏–≤–∞—Ç–æ—Ä –æ—Ñ—á–µ–π–Ω-—É—Ä–æ–≤–Ω–µ–π: —Å–ª—É—à–∞–µ—Ç bybit_order_stream –∏ –≤–∫–ª—é—á–∞–µ—Ç SL-–Ω–∞-entry/SL-–ø–µ—Ä–µ–Ω–æ—Å—ã –ø–æ—Å–ª–µ TP

# üî∏ –ò–º–ø–æ—Ä—Ç—ã
import os
import json
import asyncio
import logging
from decimal import Decimal
from typing import Dict, Tuple, Optional, Any

from trader_infra import infra

# üî∏ –õ–æ–≥–≥–µ—Ä
log = logging.getLogger("BYBIT_ACTIVATOR")

# üî∏ –°—Ç—Ä–∏–º—ã/CG
ORDER_STREAM = "bybit_order_stream"        # —Å–æ–±—ã—Ç–∏—è –∏–∑ bybit_sync (topic=order)
ACTIVATOR_CG = "bybit_activator_cg"
ACTIVATOR_CONSUMER = os.getenv("BYBIT_ACTIVATOR_CONSUMER", "bybit-activator-1")

AUDIT_STREAM = "positions_bybit_audit"     # —Å—é–¥–∞ –ø–∏—à–µ–º –∞—É–¥–∏—Ç –≤–∫–ª—é—á–µ–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π

# üî∏ –ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º –∏ –∑–∞–º–∫–∏
MAX_PARALLEL_TASKS = int(os.getenv("BYBIT_ACTIVATOR_MAX_TASKS", "200"))
LOCK_TTL_SEC = int(os.getenv("BYBIT_ACTIVATOR_LOCK_TTL", "30"))

# üî∏ –õ–æ–∫–∞–ª—å–Ω—ã–µ –º—å—é—Ç–µ–∫—Å—ã –ø–æ –∫–ª—é—á—É (strategy_id, symbol)
_local_locks: Dict[Tuple[int, str], asyncio.Lock] = {}


# üî∏ –û—Å–Ω–æ–≤–Ω–æ–π –∑–∞–ø—É—Å–∫ –∞–∫—Ç–∏–≤–∞—Ç–æ—Ä–∞
async def run_bybit_activator():
    redis = infra.redis_client

    # —Å–æ–∑–¥–∞–Ω–∏–µ CG (id="$" ‚Äî —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏)
    try:
        await redis.xgroup_create(ORDER_STREAM, ACTIVATOR_CG, id="$", mkstream=True)
        log.info("üì° –°–æ–∑–¥–∞–Ω–∞ CG %s –¥–ª—è —Å—Ç—Ä–∏–º–∞ %s", ACTIVATOR_CG, ORDER_STREAM)
    except Exception:
        # –≥—Ä—É–ø–ø–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        pass

    # —Å–±—Ä–æ—Å offset CG –Ω–∞ '$' ‚Äî —á–∏—Ç–∞–µ–º —Å—Ç—Ä–æ–≥–æ —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏ –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞
    try:
        await redis.execute_command("XGROUP", "SETID", ORDER_STREAM, ACTIVATOR_CG, "$")
        log.info("‚è© CG %s –¥–ª—è %s —Å–±—Ä–æ—à–µ–Ω–∞ –Ω–∞ $ (—Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ)", ACTIVATOR_CG, ORDER_STREAM)
    except Exception:
        log.exception("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–±—Ä–æ—Å–∏—Ç—å CG %s –¥–ª—è %s –Ω–∞ $", ACTIVATOR_CG, ORDER_STREAM)

    sem = asyncio.Semaphore(MAX_PARALLEL_TASKS)

    # —á—Ç–µ–Ω–∏–µ –∏–∑ —Å—Ç—Ä–∏–º–∞
    while True:
        try:
            batch = await redis.xreadgroup(
                groupname=ACTIVATOR_CG,
                consumername=ACTIVATOR_CONSUMER,
                streams={ORDER_STREAM: ">"},
                count=200,
                block=1000,  # –º—Å
            )
            if not batch:
                continue

            tasks = []
            for _, records in batch:
                for entry_id, fields in records:
                    tasks.append(asyncio.create_task(_handle_order_event(sem, entry_id, fields)))

            await asyncio.gather(*tasks)

        except Exception:
            log.exception("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è/–æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑ —Å—Ç—Ä–∏–º–∞ %s", ORDER_STREAM)
            await asyncio.sleep(1)


# üî∏ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–π –∑–∞–ø–∏—Å–∏ bybit_order_stream
async def _handle_order_event(sem: asyncio.Semaphore, entry_id: str, fields: Dict[str, Any]):
    async with sem:
        redis = infra.redis_client

        try:
            data_raw = fields.get("data")
            if isinstance(data_raw, bytes):
                data_raw = data_raw.decode("utf-8", errors="ignore")
            payload = json.loads(data_raw or "{}")
        except Exception:
            log.exception("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π payload order (id=%s) ‚Äî ACK", entry_id)
            try:
                await redis.xack(ORDER_STREAM, ACTIVATOR_CG, entry_id)
            except Exception:
                pass
            return

        # –∏–Ω—Ç–µ—Ä–µ—Å—É—é—Ç —Ç–æ–ª—å–∫–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –ª–∏–º–∏—Ç–Ω—ã–µ TP (orderStatus='Filled') —Å orderLinkId –≤–∏–¥–∞ ...-tN
        order_status = (payload.get("orderStatus") or "").lower()
        order_link_id = payload.get("orderLinkId")
        if not order_link_id:
            # –±–µ–∑ —Å—Å—ã–ª–∫–∏ ‚Äî –Ω–µ —Å–º–æ–∂–µ–º –∫–æ—Ä—Ä–µ–ª–∏—Ä–æ–≤–∞—Ç—å
            await _ack_ok(entry_id)
            return

        # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—Å—ë, –∫—Ä–æ–º–µ 'filled'
        if order_status != "filled":
            await _ack_ok(entry_id)
            return

        # –ø–æ–ª—É—á–∞–µ–º –∫–∞—Ä—Ç–æ—á–∫—É TP –ø–æ order_link_id
        tp_row = await _fetch_tpo_by_link(order_link_id, kind="tp")
        if not tp_row:
            # –≤–æ–∑–º–æ–∂–Ω–æ, —ç—Ç–æ –Ω–µ –Ω–∞—à TP (–∏–ª–∏ –µ—â—ë –Ω–µ —É—Å–ø–µ–ª–∏ –∑–∞–ø–∏—Å–∞—Ç—å) ‚Äî ACK –∏ –ª–æ–≥
            log.info("‚ÑπÔ∏è ORDER filled –±–µ–∑ –∏–∑–≤–µ—Å—Ç–Ω–æ–π TP-–∫–∞—Ä—Ç–æ—á–∫–∏: %s", order_link_id)
            await _ack_ok(entry_id)
            return

        position_uid = tp_row["position_uid"]
        strategy_id = int(tp_row["strategy_id"])
        symbol = tp_row["symbol"]
        direction = tp_row["direction"]
        level = int(tp_row["level"])
        order_mode = tp_row["order_mode"]

        # —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ –∫–ª—é—á—É (strategy_id, symbol)
        key = (strategy_id, symbol)
        lock = _local_locks.setdefault(key, asyncio.Lock())

        async with lock:
            # —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π –∑–∞–º–æ–∫
            gate_key = f"tv4:gate:{strategy_id}:{symbol}"
            owner = f"{ACTIVATOR_CONSUMER}-{entry_id}"
            if not await _acquire_dist_lock(gate_key, owner, LOCK_TTL_SEC):
                # –∫–æ—Ä–æ—Ç–∫–∏–π –ª–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ—Ç—Ä–∞–π –±–µ–∑ ACK
                for _ in range(10):
                    await asyncio.sleep(0.2)
                    if await _acquire_dist_lock(gate_key, owner, LOCK_TTL_SEC):
                        break
                else:
                    log.info("‚è≥ –ù–µ –≤–∑—è—Ç –∑–∞–º–æ–∫ %s ‚Äî –æ—Ç–ª–æ–∂–µ–Ω–æ (id=%s)", gate_key, entry_id)
                    return

            try:
                # –Ω–∞–π–¥—ë–º –∫–∞—Ä—Ç–æ—á–∫—É SL (on_tp, –¥–ª—è —ç—Ç–æ–≥–æ —É—Ä–æ–≤–Ω—è)
                sl_row = await _fetch_sl_on_tp(position_uid, level)
                if not sl_row:
                    # –Ω–∏—á–µ–≥–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å ‚Äî ACK
                    log.info("‚ÑπÔ∏è –ù–µ—Ç SL on_tp –¥–ª—è —É—Ä–æ–≤–Ω—è L#%s (uid=%s)", level, position_uid)
                    await _ack_ok(entry_id)
                    return

                # –µ—Å–ª–∏ qty == 0 ‚Äî –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å
                qty = _as_decimal(sl_row["qty"]) or Decimal("0")
                price = _as_decimal(sl_row["price"]) if sl_row["price"] is not None else None
                if qty <= 0:
                    log.info("‚ÑπÔ∏è SL on_tp qty=0 ‚Üí skip (uid=%s L#%s)", position_uid, level)
                    await _ack_ok(entry_id)
                    return

                # –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º SL on_tp
                await _activate_sl_on_tp(sl_row_id=sl_row["id"], order_mode=order_mode)

                # ¬´–∑–∞–º–µ–Ω—è–µ–º¬ª —Å—Ç–∞—Ä—Ç–æ–≤—ã–π SL (level=0): –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –µ–≥–æ
                await _deactivate_initial_sl(position_uid, level, reason=f"replaced by SL on TP L#{level}")

                # –∞—É–¥–∏—Ç
                await _publish_audit(
                    event="sl_on_tp_activated",
                    data={
                        "position_uid": position_uid,
                        "strategy_id": strategy_id,
                        "symbol": symbol,
                        "direction": direction,
                        "level": level,
                        "qty": str(qty),
                        "price": str(price) if price is not None else None,
                        "order_mode": order_mode,
                        "tp_order_link_id": order_link_id,
                    },
                )

                # ACK
                await _ack_ok(entry_id)
                log.info("‚úÖ SL on_tp –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω: uid=%s %s L#%s qty=%s", position_uid, symbol, level, qty)

            except Exception:
                log.exception("‚ùå –û—à–∏–±–∫–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ SL on_tp (uid=%s L#%s)", position_uid, level)
            finally:
                await _release_dist_lock(gate_key, owner)


# üî∏ ACK helper
async def _ack_ok(entry_id: str):
    try:
        await infra.redis_client.xack(ORDER_STREAM, ACTIVATOR_CG, entry_id)
    except Exception:
        pass


# üî∏ –î–æ—Å—Ç–∞–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏ TPO –ø–æ order_link_id
async def _fetch_tpo_by_link(order_link_id: str, kind: Optional[str] = None) -> Optional[dict]:
    async with infra.pg_pool.acquire() as conn:
        if kind:
            row = await conn.fetchrow(
                """
                SELECT id, position_uid, strategy_id, symbol, direction, kind, level, order_mode
                FROM trader_position_orders
                WHERE order_link_id = $1 AND kind = $2
                """,
                order_link_id, kind,
            )
        else:
            row = await conn.fetchrow(
                """
                SELECT id, position_uid, strategy_id, symbol, direction, kind, level, order_mode
                FROM trader_position_orders
                WHERE order_link_id = $1
                """,
                order_link_id,
            )
        return dict(row) if row else None


# üî∏ –ù–∞–π—Ç–∏ SL on_tp –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏/—É—Ä–æ–≤–Ω—è
async def _fetch_sl_on_tp(position_uid: str, level: int) -> Optional[dict]:
    async with infra.pg_pool.acquire() as conn:
        row = await conn.fetchrow(
            """
            SELECT id, qty, price, status
            FROM trader_position_orders
            WHERE position_uid = $1
              AND kind = 'sl'
              AND activation = 'on_tp'
              AND activation_tp_level = $2
              AND status = 'planned_offchain'
              AND is_active = true
            """,
            position_uid, level,
        )
        return dict(row) if row else None

# üî∏ –ü–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–π —Å—Ç–æ–ø-–ª–æ—Å—Å (live) ‚Äî /v5/position/trading-stop
async def _set_position_stop_loss_live(
    *,
    symbol: str,
    trigger_price: Decimal,
    trigger_by: str = "LastPrice",
    position_idx: int = 0
) -> dict:
    # —É—Å–ª–æ–≤–∏—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ—Å—Ç–∏ –∏ –∫–≤–∞–Ω—Ç —Ü–µ–Ω—ã
    async with infra.pg_pool.acquire() as conn:
        tr = await conn.fetchrow(
            """
            SELECT COALESCE(ticksize,0) AS ticksize,
                   COALESCE(precision_price,0) AS pprice
            FROM tickers_bb
            WHERE symbol = $1
            """,
            symbol,
        )

    from decimal import Decimal, ROUND_DOWN

    # –ª–æ–∫–∞–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã
    def _quant_down_local(value: Decimal, step: Decimal):
        try:
            if value is None or step is None or step <= 0:
                return None
            return (value / step).to_integral_value(rounding=ROUND_DOWN) * step
        except Exception:
            return None

    def _to_fixed_str_local(d: Decimal) -> str:
        s = format(d, "f")
        if "." in s:
            s = s.rstrip("0").rstrip(".")
        return s or "0"

    ticksize = Decimal(str(tr["ticksize"])) if tr and tr["ticksize"] is not None else Decimal("0")
    pprice   = int(tr["pprice"]) if tr else 0
    step_price = ticksize if (ticksize and ticksize > 0) else (Decimal("1").scaleb(-pprice) if pprice > 0 else Decimal("0.00000001"))

    p = _quant_down_local(trigger_price, step_price)
    if p is None or p <= 0:
        raise ValueError("invalid SL trigger price")

    # –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∏ –ø–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞
    import os, time, hmac, hashlib, json, httpx

    API_KEY     = os.getenv("BYBIT_API_KEY", "")
    API_SECRET  = os.getenv("BYBIT_API_SECRET", "")
    BASE_URL    = os.getenv("BYBIT_BASE_URL", "https://api.bybit.com")
    RECV_WINDOW = os.getenv("BYBIT_RECV_WINDOW", "5000")

    if not API_KEY or not API_SECRET:
        raise RuntimeError("missing Bybit API credentials")

    body = {
        "category": "linear",
        "symbol": symbol,
        "positionIdx": position_idx,          # oneway ‚Üí 0
        "stopLoss": _to_fixed_str_local(p),
        "slTriggerBy": trigger_by,            # 'LastPrice'
    }

    url = f"{BASE_URL}/v5/position/trading-stop"
    ts = int(time.time() * 1000)
    body_json = json.dumps(body, separators=(",", ":"))
    payload = f"{ts}{API_KEY}{RECV_WINDOW}{body_json}"
    sign = hmac.new(API_SECRET.encode("utf-8"), payload.encode("utf-8"), hashlib.sha256).hexdigest()
    headers = {
        "X-BAPI-API-KEY": API_KEY,
        "X-BAPI-TIMESTAMP": str(ts),
        "X-BAPI-RECV-WINDOW": RECV_WINDOW,
        "X-BAPI-SIGN": sign,
        "Content-Type": "application/json",
    }

    async with httpx.AsyncClient(timeout=10) as client:
        r = await client.post(url, headers=headers, content=body_json)
        r.raise_for_status()
        return r.json()
        
# üî∏ –ê–∫—Ç–∏–≤–∞—Ü–∏—è SL on_tp: –≤ dry_run ‚Äî —Å—Ç–∞—Ç—É—Å 'sent'; –≤ live ‚Äî –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–π —Å—Ç–æ–ø —á–µ—Ä–µ–∑ /v5/position/trading-stop
async def _activate_sl_on_tp(sl_row_id: int, order_mode: str):
    async with infra.pg_pool.acquire() as conn:
        if order_mode == "dry_run":
            await conn.execute(
                """
                UPDATE trader_position_orders
                SET status = 'sent',
                    updated_at = now(),
                    note = COALESCE(note,'') || CASE WHEN COALESCE(note,'')='' THEN '' ELSE '; ' END || 'activated by TP'
                WHERE id = $1
                """,
                sl_row_id,
            )
            return

    # live: –ø–æ–¥—Ç—è–≥–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ SL-–∫–∞—Ä—Ç–æ—á–∫–∏ –∏ —Å–∏–º–≤–æ–ª
    try:
        async with infra.pg_pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT position_uid, symbol, direction, level, qty, price
                FROM trader_position_orders
                WHERE id = $1
                """,
                sl_row_id,
            )
        if not row:
            return  # –Ω–µ –Ω–∞—à–ª–∏ –∫–∞—Ä—Ç–æ—á–∫—É ‚Äî —Ç–∏—Ö–æ –≤—ã—Ö–æ–¥–∏–º

        # –±–∞–∑–æ–≤—ã–µ –ø–æ–ª—è
        position_uid = row["position_uid"]
        symbol       = row["symbol"]
        level        = int(row["level"]) if row["level"] is not None else None
        qty          = _as_decimal(row["qty"])
        price_raw    = _as_decimal(row["price"])

        # —É—Å–ª–æ–≤–∏—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ—Å—Ç–∏
        if price_raw is None or price_raw <= 0:
            raise ValueError("invalid SL trigger price")

        # —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–π —Å—Ç–æ–ø —á–µ—Ä–µ–∑ –æ–±—â–∏–π —Ö–µ–ª–ø–µ—Ä
        resp = await _set_position_stop_loss_live(
            symbol=symbol,
            trigger_price=price_raw,    # –∫–≤–∞–Ω—Ç–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤–Ω—É—Ç—Ä–∏ —Ö–µ–ª–ø–µ—Ä–∞
            trigger_by="LastPrice",
            position_idx=0,
        )
        ret_code = (resp or {}).get("retCode", 0)
        ret_msg  = (resp or {}).get("retMsg")

        if ret_code == 0:
            # —É—Å–ø–µ—Ö ‚Äî –ø–æ–º–µ—á–∞–µ–º –∫–∞—Ä—Ç–æ—á–∫—É SL on_tp –∫–∞–∫ 'sent' –∏ –ª–æ–≥–∏—Ä—É–µ–º –∞—É–¥–∏—Ç
            async with infra.pg_pool.acquire() as conn:
                await conn.execute(
                    """
                    UPDATE trader_position_orders
                    SET status = 'sent',
                        updated_at = now(),
                        note = COALESCE(note,'') || CASE WHEN COALESCE(note,'')='' THEN '' ELSE '; ' END || 'activated by TP (position stop set)'
                    WHERE id = $1
                    """,
                    sl_row_id,
                )
            await _publish_audit(
                event="sl_position_updated",
                data={
                    "position_uid": position_uid,
                    "symbol": symbol,
                    "level": level,
                    "qty": str(qty) if qty is not None else None,
                    "price": str(price_raw),
                },
            )
            log.info("üì§ position stop updated on TP: uid=%s %s L#%s price=%s",
                     position_uid, symbol, level, price_raw)
        else:
            # –æ—à–∏–±–∫–∞ ‚Äî –æ—Å—Ç–∞–≤–∏–º –∫–∞—Ä—Ç–æ—á–∫—É –∫–∞–∫ planned_offchain –∏ –∑–∞–∞—É–¥–∏—Ç–∏–º —Ñ–µ–π–ª
            await _publish_audit(
                event="sl_position_update_failed",
                data={
                    "position_uid": position_uid,
                    "symbol": symbol,
                    "level": level,
                    "qty": str(qty) if qty is not None else None,
                    "price": str(price_raw),
                    "retCode": ret_code,
                    "retMsg": ret_msg,
                },
            )
            log.info("‚ùó position stop update failed on TP: uid=%s %s L#%s ret=%s %s",
                     position_uid, symbol, level, ret_code, ret_msg)

    except Exception as e:
        # –º—è–≥–∫–∏–π —Ñ–æ–ª–±—ç–∫: –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ 'planned' (–∫–∞–∫ –±—ã–ª–æ), —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å
        async with infra.pg_pool.acquire() as conn:
            await conn.execute(
                """
                UPDATE trader_position_orders
                SET status = 'planned',
                    updated_at = now(),
                    note = COALESCE(note,'') || CASE WHEN COALESCE(note,'')='' THEN '' ELSE '; ' END ||
                           ('activation planned (live): ' || $2)
                WHERE id = $1
                """,
                sl_row_id, str(e),
            )
        await _publish_audit(
            event="sl_position_update_failed",
            data={"row_id": sl_row_id, "reason": "exception", "error": str(e)},
        )
        log.exception("‚ùå exception while updating position stop on TP (id=%s)", sl_row_id)
        
# üî∏ –î–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ SL (level=0) –ø—Ä–∏ –∑–∞–º–µ–Ω–µ –Ω–∞ SL on_tp
async def _deactivate_initial_sl(position_uid: str, level_triggered: int, reason: str):
    async with infra.pg_pool.acquire() as conn:
        await conn.execute(
            """
            UPDATE trader_position_orders
            SET is_active = false,
                status = CASE WHEN status IN ('planned','sent') THEN 'canceled' ELSE status END,
                updated_at = now(),
                note = COALESCE(note,'') || CASE WHEN COALESCE(note,'')='' THEN '' ELSE '; ' END || $2
            WHERE position_uid = $1
              AND kind = 'sl'
              AND level = 0
              AND is_active = true
            """,
            position_uid,
            f"replaced by SL on TP L#{level_triggered}: {reason}",
        )


# üî∏ –ê—É–¥–∏—Ç-—Å–æ–±—ã—Ç–∏–µ
async def _publish_audit(event: str, data: dict):
    payload = {"event": event, **(data or {})}
    sid = await infra.redis_client.xadd(AUDIT_STREAM, {"data": json.dumps(payload)})
    log.info("üìú audit %s ‚Üí %s: %s", event, AUDIT_STREAM, payload)
    return sid


# üî∏ –†–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π –∑–∞–º–æ–∫ (SET NX EX)
async def _acquire_dist_lock(key: str, value: str, ttl: int) -> bool:
    try:
        ok = await infra.redis_client.set(key, value, ex=ttl, nx=True)
        return bool(ok)
    except Exception:
        log.exception("‚ùå –û—à–∏–±–∫–∞ acquire lock %s", key)
        return False


# üî∏ –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –∑–∞–º–∫–∞ –ø–æ –≤–ª–∞–¥–µ–ª—å—Ü—É (Lua check-and-del)
async def _release_dist_lock(key: str, value: str):
    if not key:
        return
    try:
        lua = """
        if redis.call('get', KEYS[1]) == ARGV[1] then
            return redis.call('del', KEYS[1])
        else
            return 0
        end
        """
        await infra.redis_client.eval(lua, 1, key, value)
    except Exception:
        log.debug("lock release fallback (key=%s)", key)


# üî∏ –£—Ç–∏–ª–∏—Ç—ã
def _as_decimal(v) -> Optional[Decimal]:
    try:
        if v is None:
            return None
        if isinstance(v, Decimal):
            return v
        return Decimal(str(v))
    except Exception:
        return None