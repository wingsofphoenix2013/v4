# trader_tg_notifier.py ‚Äî –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram (open/close),
# —Å —Ä–æ—Ç–∏—Ä—É–µ–º—ã–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏, —Å—Ç—Ä–µ–ª–∫–∞–º–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è, –∞–∫–∫—É—Ä–∞—Ç–Ω—ã–º–∏ –ø–µ—Ä–µ–Ω–æ—Å–∞–º–∏ —Å—Ç—Ä–æ–∫,
# TP/SL –≤ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –∏ –ø–æ—Ä—Ç—Ñ–µ–ª—å–Ω—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏ (24h/TOTAL ROI & Winrate) –≤ –∑–∞–∫—Ä—ã—Ç–∏–∏.
#
# ‚ö†Ô∏è –í–∞–∂–Ω–æ: –≤ —Å—Ç—Ä–æ–∫–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¢–û–õ–¨–ö–û strategies_v4.name (–Ω–µ human_name).

# üî∏ –ò–º–ø–æ—Ä—Ç—ã
import os
import logging
import random
from decimal import Decimal
from datetime import datetime
from typing import Optional, Iterable, Any
import httpx

# üî∏ –õ–æ–≥–≥–µ—Ä —Ç–µ–ª–µ–≥—Ä–∞–º-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
log = logging.getLogger("TRADER_TG")

# üî∏ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (–±–µ—Ä—ë–º –∏–∑ ENV)
_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")  # –¥–ª—è –∫–∞–Ω–∞–ª–æ–≤ –∏–Ω–æ–≥–¥–∞ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ

# üî∏ –ù–∞–±–æ—Ä—ã –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ (—Ä–æ—Ç–∏—Ä—É—é—Ç—Å—è —Å–ª—É—á–∞–π–Ω–æ)
_OPEN_HEADERS = [
    "üöÄ We‚Äôre in ‚Äî fresh entry on the board",
    "üéØ Button pressed. Position live.",
    "üß≠ New position deployed ‚Äî let‚Äôs navigate",
    "‚öôÔ∏è Switch flipped ‚Äî trade engaged",
    "ü•∑ Silent entry ‚Äî let‚Äôs hunt",
]

_WIN_HEADERS = [
    "üü¢ Profit secured ‚Äî the market blinked first üòé",
    "üü¢ Winner winner, crypto dinner üçΩÔ∏è",
    "üü¢ Green ink day ‚Äî we got paid üíö",
    "üü¢ That exit slapped ‚Äî bag secured üí∞",
    "üü¢ Trend befriended, wallet defended üõ°Ô∏è",
]

_LOSS_HEADERS = [
    "üî¥ Ouch. Market said ‚Äúnope.‚Äù Moving on. üßä",
    "üî¥ Tuition paid to Mr. Market. Class dismissed. üìâ",
    "üî¥ We took one on the chin ‚Äî next one‚Äôs ours üëä",
    "üî¥ Red day, cool head. Reset and reload üîÅ",
    "üî¥ Loss logged, ego intact. Back to the lab üß™",
]

# üî∏ –ë–∞–∑–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞ (HTML)
async def tg_send(text: str, *, disable_notification: bool = False) -> None:
    if not _BOT_TOKEN or not _CHAT_ID:
        log.debug("‚ÑπÔ∏è TG: –ø—Ä–æ–ø—É—Å–∫ ‚Äî TELEGRAM_BOT_TOKEN/TELEGRAM_CHAT_ID –Ω–µ –∑–∞–¥–∞–Ω—ã")
        return

    url = f"https://api.telegram.org/bot{_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": _CHAT_ID,
        "text": text,
        "parse_mode": "HTML",
        "disable_web_page_preview": True,
        "disable_notification": disable_notification,
    }

    try:
        async with httpx.AsyncClient(timeout=10) as client:
            r = await client.post(url, json=payload)
            if r.status_code != 200:
                log.warning("‚ö†Ô∏è TG: %s %s", r.status_code, r.text)
            else:
                log.debug("üì® TG: –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
    except Exception:
        log.exception("‚ùå TG: –æ—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏")

# üî∏ –ü—É–±–ª–∏—á–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–∏: open/close

async def send_open_notification(
    *,
    symbol: str,
    direction: Optional[str],
    entry_price: Optional[Decimal],
    strategy_name: str,         # ‚Üê –¢–û–õ–¨–ö–û strategies_v4.name
    created_at: datetime,
    tp_targets: Optional[Iterable[Any]] = None,  # —Å–ø–∏—Å–æ–∫ TP (dict/tuple)
    sl_targets: Optional[Iterable[Any]] = None,  # —Å–ø–∏—Å–æ–∫ SL (dict/tuple)
    header: Optional[str] = None,
    silent: bool = False,
) -> None:
    # –∑–∞–≥–æ–ª–æ–≤–æ–∫ (–±–µ–∑ üü¢/üî¥ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏–π)
    hdr = header or random.choice(_OPEN_HEADERS)
    text = build_open_message(
        header=hdr,
        symbol=symbol,
        direction=direction,
        entry_price=entry_price,
        created_at=created_at,
        strategy_name=strategy_name,
        tp_targets=tp_targets,
        sl_targets=sl_targets,
    )
    await tg_send(text, disable_notification=silent)

async def send_closed_notification(
    *,
    symbol: str,
    direction: Optional[str],
    pnl: Optional[Decimal],
    strategy_name: str,          # ‚Üê –¢–û–õ–¨–ö–û strategies_v4.name
    created_at: Optional[datetime],  # –¥–ª—è Held (–º–∏–Ω—É—Ç—ã)
    closed_at: Optional[datetime],   # –¥–ª—è Held (–º–∏–Ω—É—Ç—ã)
    roi_24h: Optional[Decimal] = None,   # –ø–æ—Ä—Ç—Ñ–µ–ª—å–Ω—ã–π 24h ROI (–¥–æ–ª—è)
    roi_total: Optional[Decimal] = None, # –ø–æ—Ä—Ç—Ñ–µ–ª—å–Ω—ã–π TOTAL ROI (–¥–æ–ª—è)
    wr_24h: Optional[Decimal] = None,    # –ø–æ—Ä—Ç—Ñ–µ–ª—å–Ω—ã–π 24h Winrate (–¥–æ–ª—è 0..1)
    wr_total: Optional[Decimal] = None,  # –ø–æ—Ä—Ç—Ñ–µ–ª—å–Ω—ã–π TOTAL Winrate (–¥–æ–ª—è 0..1)
    header: Optional[str] = None,
    silent: bool = False,
) -> None:
    # –∑–∞–≥–æ–ª–æ–≤–æ–∫: win –∏–ª–∏ loss (—Å üü¢/üî¥)
    if header:
        hdr = header
    else:
        is_win = (pnl or Decimal("0")) >= 0
        hdr = random.choice(_WIN_HEADERS if is_win else _LOSS_HEADERS)

    text = build_closed_message(
        header=hdr,
        symbol=symbol,
        direction=direction,
        pnl=pnl,
        strategy_name=strategy_name,
        created_at=created_at,
        closed_at=closed_at,
        roi_24h=roi_24h,
        roi_total=roi_total,
        wr_24h=wr_24h,
        wr_total=wr_total,
    )
    await tg_send(text, disable_notification=silent)

# üî∏ –§–æ—Ä–º–∞—Ç—Ç–µ—Ä—ã

def _fmt_money(x: Optional[Decimal], max_prec: int = 8) -> str:
    if x is None:
        return "‚Äî"
    try:
        s = f"{x:.{max_prec}f}".rstrip("0").rstrip(".")
        return s if s else "0"
    except Exception:
        return str(x)

def _fmt_signed(x: Optional[Decimal], max_prec: int = 8) -> str:
    if x is None:
        return "‚Äî"
    try:
        sign = "+" if x >= 0 else ""
        return f"{sign}{_fmt_money(x, max_prec)}"
    except Exception:
        return str(x)

def _fmt_pct(x: Optional[Decimal], max_prec: int = 2) -> str:
    if x is None:
        return "‚Äî"
    try:
        val = x * Decimal("100")  # –¥–æ–ª—è ‚Üí –ø—Ä–æ—Ü–µ–Ω—Ç—ã
        sign = "+" if val >= 0 else ""
        s = f"{val:.{max_prec}f}".rstrip("0").rstrip(".")
        return f"{sign}{s}%"
    except Exception:
        return str(x)

def _fmt_dt_utc(dt: Optional[datetime]) -> str:
    if not dt:
        return "‚Äî"
    # timestamps –≤ –ë–î –Ω–∞–∏–≤–Ω—ã–µ UTC ‚Äî –ø–æ–º–µ—á–∞–µ–º —è–≤–Ω–æ
    return dt.strftime("%Y-%m-%d %H:%M") + " UTC"

def _side_arrow_and_word(direction: Optional[str]) -> tuple[str, str]:
    # ‚¨ÜÔ∏è long, ‚¨áÔ∏è short
    d = (direction or "").lower()
    return ("‚¨ÜÔ∏è", "LONG") if d == "long" else ("‚¨áÔ∏è", "SHORT")

def _level_from(obj: Any) -> Optional[int]:
    try:
        if isinstance(obj, dict):
            return int(obj.get("level")) if obj.get("level") is not None else None
        if isinstance(obj, (tuple, list)) and len(obj) >= 1:
            return int(obj[0]) if obj[0] is not None else None
    except Exception:
        return None
    return None

def _price_from(obj: Any) -> Optional[Decimal]:
    try:
        if isinstance(obj, dict):
            v = obj.get("price")
        else:
            v = obj[1] if isinstance(obj, (tuple, list)) and len(obj) >= 2 else None
        if v is None:
            return None
        if isinstance(v, Decimal):
            return v
        return Decimal(str(v))
    except Exception:
        return None

def _format_tp_section(tp_targets: Optional[Iterable[Any]], max_items: int = 3) -> str:
    """TP-–±–ª–æ–∫ –±–µ–∑ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ ‚Äî —Ç–æ–ª—å–∫–æ —Ü–µ–Ω—ã (–ø–æ –∑–∞–¥–∞–Ω–∏—é)."""
    if not tp_targets:
        return ""
    try:
        tps = sorted(tp_targets, key=lambda t: (_level_from(t) or 10**9))
    except Exception:
        tps = list(tp_targets)

    lines = []
    shown = 0
    for t in tps:
        if shown >= max_items:
            break
        lvl = _level_from(t)
        price = _price_from(t)
        lvl_txt = f"TP{lvl}" if lvl is not None else "TP"
        price_txt = _fmt_money(price)
        lines.append(f"üéØ {lvl_txt}: <code>{price_txt}</code>")
        shown += 1

    more = len(tps) - shown
    suffix = f"\n‚ûï ... and {more} more TP" if more > 0 else ""
    # –¥–æ–±–∞–≤–∏–º –∑–∞–≤–µ—Ä—à–∞—é—â–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Å—Ç—Ä–æ–∫–∏, –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ –ø–æ–∫–∞–∑–∞—Ç—å
    return ("\n".join(lines)) + suffix + ("\n" if lines or suffix else "")

def _format_sl_section(sl_targets: Optional[Iterable[Any]]) -> str:
    if not sl_targets:
        return ""
    # –±–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π (–æ–±—ã—á–Ω–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π) SL
    sl = None
    for s in sl_targets:
        sl = s
        break
    price = _price_from(sl)
    price_txt = _fmt_money(price)
    return f"üõ°Ô∏è SL: <code>{price_txt}</code>\n"

# üî∏ –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã —Å–æ–æ–±—â–µ–Ω–∏–π

def build_open_message(
    *,
    header: str,
    symbol: str,
    direction: Optional[str],
    entry_price: Optional[Decimal],
    created_at: datetime,
    strategy_name: str,
    tp_targets: Optional[Iterable[Any]] = None,
    sl_targets: Optional[Iterable[Any]] = None,
) -> str:
    """
    –ò—Ç–æ–≥–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç:
    <header>

    ‚¨ÜÔ∏è LONG on <symbol>

    üéØ Entry: <entry_price>
    üéØ TP1: <price>
    üõ°Ô∏è SL: <price>

    üß† Strategy: <name>

    ‚è≥ <created_at UTC>
    """
    arrow, side = _side_arrow_and_word(direction)
    tp_block = _format_tp_section(tp_targets)
    sl_block = _format_sl_section(sl_targets)

    parts = [
        f"{header}",
        "",
        f"{arrow} {side} on <b>{symbol}</b>",
        "",
        f"üéØ Entry: <code>{_fmt_money(entry_price)}</code>",
        tp_block.rstrip("\n"),
        sl_block.rstrip("\n"),
        "",
        f"üß† Strategy: {strategy_name}",
        "",
        f"‚è≥ {_fmt_dt_utc(created_at)}",
    ]
    # —É–±–µ—Ä—ë–º –ª–∏—à–Ω–∏–µ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –æ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø—É—Å—Ç—ã—Ö TP/SL –±–ª–æ–∫–æ–≤
    text = "\n".join([line for line in parts if line is not None])
    while "\n\n\n" in text:
        text = text.replace("\n\n\n", "\n\n")
    return text

def build_closed_message(
    *,
    header: str,
    symbol: str,
    direction: Optional[str],
    pnl: Optional[Decimal],
    strategy_name: str,
    created_at: Optional[datetime],
    closed_at: Optional[datetime],
    roi_24h: Optional[Decimal] = None,   # –¥–æ–ª—è (0.0123 ‚Üí 1.23%)
    roi_total: Optional[Decimal] = None, # –¥–æ–ª—è
    wr_24h: Optional[Decimal] = None,    # –¥–æ–ª—è
    wr_total: Optional[Decimal] = None,  # –¥–æ–ª—è
) -> str:
    """
    –ò—Ç–æ–≥–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç:
    <win/loss header>

    ‚¨ÜÔ∏è LONG on <symbol>
    üß† Strategy: <name>

    üíµ PnL: +...

    üìà 24h ROI: +..%
    üìä TOTAL ROI: +..%

    ü•á 24h Winrate: ..%
    üèÜ TOTAL Winrate: ..%

    üïì Held: X minutes
    """
    arrow, side = _side_arrow_and_word(direction)

    # –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —É–¥–µ—Ä–∂–∞–Ω–∏—è (–º–∏–Ω—É—Ç—ã)
    held_line = "üïì Held: ‚Äî"
    if created_at and closed_at:
        try:
            minutes = int((closed_at - created_at).total_seconds() // 60)
            held_line = f"üïì Held: {minutes} minutes"
        except Exception:
            pass

    lines = [
        f"{header}",
        "",
        f"{arrow} {side} on <b>{symbol}</b>",
        f"üß† Strategy: {strategy_name}",
        "",
        f"üíµ PnL: <b>{_fmt_signed(pnl)}</b>",
        "",
        f"üìà 24h ROI: <b>{_fmt_pct(roi_24h)}</b>",
        f"üìä TOTAL ROI: <b>{_fmt_pct(roi_total)}</b>",
        "",
        f"ü•á 24h Winrate: <b>{_fmt_pct(wr_24h)}</b>",
        f"üèÜ TOTAL Winrate: <b>{_fmt_pct(wr_total)}</b>",
        "",
        held_line,
    ]
    return "\n".join(lines)