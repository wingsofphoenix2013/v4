# strategy_registry.py

import logging
import json
import aiohttp

from infra import infra

log = logging.getLogger("STRATEGY_REGISTRY")

# üî∏ –ö–µ—à —Å—Ç—Ä–∞—Ç–µ–≥–∏–π: strategy_id ‚Üí {leverage, sl_policy, tp_levels}
binance_strategies: dict[int, dict] = {}

# üî∏ –ö–µ—à —Ç–æ—á–Ω–æ—Å—Ç–µ–π —Ç–∏–∫–µ—Ä–æ–≤: symbol ‚Üí precision_qty
symbol_precision_map: dict[str, int] = {}
symbol_price_precision_map: dict[str, int] = {}
symbol_tick_size_map: dict[str, float] = {}
symbol_min_qty_map: dict[str, float] = {}

# üî∏ –ö–∞–Ω–∞–ª Pub/Sub –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
PUBSUB_CHANNEL = "binance_strategy_updates"

# üî∏ –ó–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π Binance –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
async def load_binance_enabled_strategies():
    # –®–∞–≥ 1: –±–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
    query_base = """
        SELECT s.id AS strategy_id, s.leverage, s.use_stoploss, s.sl_type, s.sl_value
        FROM strategies_v4 s
        WHERE s.binance_enabled = true
    """
    base_rows = await infra.pg_pool.fetch(query_base)

    binance_strategies.clear()

    for row in base_rows:
        sid = row["strategy_id"]
        binance_strategies[sid] = {
            "leverage": int(row["leverage"] or 1),
            "use_stoploss": row["use_stoploss"],
            "sl_type": row["sl_type"],
            "sl_value": row["sl_value"],
            "sl_policy": {},
            "tp_levels": {}
        }

    # –®–∞–≥ 2: TP/SL —É—Ä–æ–≤–Ω–∏
    query_tp_sl = """
        SELECT s.id AS strategy_id,
               tp.level AS tp_level, tp.tp_type, tp.tp_value, tp.volume_percent,
               sl.sl_mode, sl.sl_value
        FROM strategies_v4 s
        LEFT JOIN strategy_tp_levels_v4 tp ON tp.strategy_id = s.id
        LEFT JOIN strategy_tp_sl_v4 sl ON sl.strategy_id = s.id AND sl.tp_level_id = tp.id
        WHERE s.binance_enabled = true
    """
    rows = await infra.pg_pool.fetch(query_tp_sl)

    for row in rows:
        sid = row["strategy_id"]
        level = row["tp_level"]

        if sid not in binance_strategies:
            continue

        if level is not None:
            if row["sl_mode"] is not None:
                binance_strategies[sid]["sl_policy"][level] = {
                    "sl_mode": row["sl_mode"],
                    "sl_value": row["sl_value"]
                }

            binance_strategies[sid]["tp_levels"][level] = {
                "tp_type": row["tp_type"],
                "tp_value": row["tp_value"],
                "volume_percent": row["volume_percent"]
            }

    log.info(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(binance_strategies)} —Å—Ç—Ä–∞—Ç–µ–≥–∏–π —Å binance_enabled=true")

    for sid, cfg in binance_strategies.items():
        log.info(f"üî∏ –°—Ç—Ä–∞—Ç–µ–≥–∏—è {sid}: leverage={cfg['leverage']}, SL={cfg['sl_type']} {cfg['sl_value']}%")
        for level, tp in sorted(cfg["tp_levels"].items()):
            log.info(f"   ‚Ä¢ TP{level}: type={tp['tp_type']} value={tp['tp_value']} ‚Üí {tp['volume_percent']}%")
        if not cfg["tp_levels"]:
            log.info("   ‚Ä¢ TP —É—Ä–æ–≤–Ω–∏: –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç")


# üî∏ –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –ø–æ–¥–≥—Ä—É–∑–∫–∞ –ø–æ–ª–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
async def load_single_strategy(strategy_id: int):
    query_base = """
        SELECT s.id AS strategy_id, s.leverage, s.use_stoploss, s.sl_type, s.sl_value
        FROM strategies_v4 s
        WHERE s.id = $1
    """
    base = await infra.pg_pool.fetchrow(query_base, strategy_id)

    if not base:
        return

    binance_strategies[strategy_id] = {
        "leverage": int(base["leverage"] or 1),
        "use_stoploss": base["use_stoploss"],
        "sl_type": base["sl_type"],
        "sl_value": base["sl_value"],
        "sl_policy": {},
        "tp_levels": {}
    }

    query_tp_sl = """
        SELECT tp.level AS tp_level, tp.tp_type, tp.tp_value, tp.volume_percent,
               sl.sl_mode, sl.sl_value
        FROM strategy_tp_levels_v4 tp
        LEFT JOIN strategy_tp_sl_v4 sl ON sl.strategy_id = $1 AND sl.tp_level_id = tp.id
        WHERE tp.strategy_id = $1
    """
    rows = await infra.pg_pool.fetch(query_tp_sl, strategy_id)

    for row in rows:
        level = row["tp_level"]

        if level is not None:
            if row["sl_mode"] is not None:
                binance_strategies[strategy_id]["sl_policy"][level] = {
                    "sl_mode": row["sl_mode"],
                    "sl_value": row["sl_value"]
                }

            binance_strategies[strategy_id]["tp_levels"][level] = {
                "tp_type": row["tp_type"],
                "tp_value": row["tp_value"],
                "volume_percent": row["volume_percent"]
            }

    log.info(f"üîÅ –°—Ç—Ä–∞—Ç–µ–≥–∏—è {strategy_id} –ø–æ–¥–≥—Ä—É–∂–µ–Ω–∞ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏")
     
# üî∏ –ü—Ä–æ–≤–µ—Ä–∫–∞: —Ä–∞–∑—Ä–µ—à–µ–Ω–∞ –ª–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –¥–ª—è Binance
def is_strategy_binance_enabled(strategy_id: int) -> bool:
    return strategy_id in binance_strategies


# üî∏ –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–ª–µ—á–∞ –ø–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1)
def get_leverage(strategy_id: int) -> int:
    return binance_strategies.get(strategy_id, {}).get("leverage", 1)


# üî∏ –ü–æ–ª—É—á–µ–Ω–∏–µ SL-–ø–æ–ª–∏—Ç–∏–∫–∏ –¥–ª—è TP-—É—Ä–æ–≤–Ω—è
def get_sl_policy(strategy_id: int, tp_level: int) -> dict | None:
    return binance_strategies.get(strategy_id, {}).get("sl_policy", {}).get(tp_level)


# üî∏ –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
def get_strategy_config(strategy_id: int) -> dict | None:
    return binance_strategies.get(strategy_id)

# üî∏ –°–ª—É—à–∞—Ç–µ–ª—å Redis Pub/Sub –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –≤ –∫–µ—à–µ
async def run_binance_strategy_watcher():
    pubsub = infra.redis_client.pubsub()
    await pubsub.subscribe(PUBSUB_CHANNEL)

    log.info(f"üì° –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª Redis: {PUBSUB_CHANNEL}")

    async for message in pubsub.listen():
        if message["type"] != "message":
            continue

        try:
            payload = json.loads(message["data"])
            strategy_id = int(payload["strategy_id"])
            enabled = bool(payload["binance_enabled"])

            if enabled:
                await load_single_strategy(strategy_id)
            else:
                binance_strategies.pop(strategy_id, None)
                log.info(f"üö´ –°—Ç—Ä–∞—Ç–µ–≥–∏—è {strategy_id} –æ—Ç–∫–ª—é—á–µ–Ω–∞ –æ—Ç Binance")

        except Exception:
            log.exception(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ {PUBSUB_CHANNEL}")

# üî∏ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ—á–Ω–æ—Å—Ç–µ–π —Ç–∏–∫–µ—Ä–æ–≤ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã tickers_v4 + tickSize –∏–∑ Binance
async def load_symbol_precisions():
    query = "SELECT symbol, precision_qty, precision_price, min_qty FROM tickers_v4"
    rows = await infra.pg_pool.fetch(query)

    symbol_precision_map.clear()
    symbol_price_precision_map.clear()
    symbol_tick_size_map.clear()
    symbol_min_qty_map.clear()

    for row in rows:
        symbol = row["symbol"]
        qty_precision = row["precision_qty"]
        price_precision = row["precision_price"]
        min_qty = row["min_qty"]

        if symbol:
            if qty_precision is not None:
                symbol_precision_map[symbol] = qty_precision
            if price_precision is not None:
                symbol_price_precision_map[symbol] = price_precision
            if min_qty is not None:
                symbol_min_qty_map[symbol] = float(min_qty)

    try:
        async with aiohttp.ClientSession() as session:
            async with session.get("https://fapi.binance.com/fapi/v1/exchangeInfo") as resp:
                data = await resp.json()
                all_symbols = {s["symbol"]: s for s in data.get("symbols", [])}

                for symbol in sorted(symbol_precision_map):
                    entry = all_symbols.get(symbol)
                    if not entry:
                        log.warning(f"‚ùì {symbol} –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ Binance exchangeInfo")
                        continue

                    bin_qty = entry.get("quantityPrecision")
                    bin_price = entry.get("pricePrecision")

                    db_qty = symbol_precision_map.get(symbol, "-")
                    db_price = symbol_price_precision_map.get(symbol, "-")

                    # üî∏ tickSize
                    price_filter = next(
                        (f for f in entry.get("filters", []) if f["filterType"] == "PRICE_FILTER"),
                        None
                    )
                    tick_size = float(price_filter["tickSize"]) if price_filter else None
                    if tick_size:
                        symbol_tick_size_map[symbol] = tick_size

                    match_qty = "‚úÖ" if bin_qty == db_qty else "‚ùó"
                    match_price = "‚úÖ" if bin_price == db_price else "‚ùó"

                    # üî∏ tickSize vs min_qty
                    db_tick = symbol_min_qty_map.get(symbol)
                    if db_tick is not None and abs(tick_size - db_tick) > 1e-10:
                        match_tick = "‚ùó"
                        log.info(f"  ‚Ä¢ {symbol:<10} | DB: tick={db_tick} | Binance: tick={tick_size} {match_tick}")
                    else:
                        match_tick = "‚úÖ"

                    log.info(
                        f"  ‚Ä¢ {symbol:<10} | DB: qty={db_qty}, price={db_price} | "
                        f"Binance: qty={bin_qty}, price={bin_price} | tick={tick_size} {match_qty}{match_price}{match_tick}"
                    )

    except Exception as e:
        log.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ—Ç Binance: {e}")

    log.info(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ quantity precision –¥–ª—è {len(symbol_precision_map)} —Ç–∏–∫–µ—Ä–æ–≤")
    log.info(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ price precision –¥–ª—è {len(symbol_price_precision_map)} —Ç–∏–∫–µ—Ä–æ–≤")
    log.info(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ tickSize –¥–ª—è {len(symbol_tick_size_map)} —Ç–∏–∫–µ—Ä–æ–≤")
    
# üî∏ –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏ quantity –ø–æ —Å–∏–º–≤–æ–ª—É
def get_precision_for_symbol(symbol: str) -> int:
    return symbol_precision_map.get(symbol, 3)


# üî∏ –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏ price –ø–æ —Å–∏–º–≤–æ–ª—É
def get_price_precision_for_symbol(symbol: str) -> int:
    return symbol_price_precision_map.get(symbol, 2)