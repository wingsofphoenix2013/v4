# auditor.py ‚Äî –∞—É–¥–∏—Ç —Å–∏—Å—Ç–µ–º—ã: —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏ –ø—Ä–æ–ø—É—Å–∫–∏

import logging
from datetime import datetime, timedelta

# üî∏ –ë–∞–∑–æ–≤—ã–π –∞—É–¥–∏—Ç —Ç–µ–∫—É—â–µ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å–∏—Å—Ç–µ–º—ã
async def analyze_config_state(pg):
    log = logging.getLogger("GAP_CHECKER")

    async with pg.acquire() as conn:
        # üîπ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∏–∫–µ—Ä–æ–≤
        row = await conn.fetchrow("""
            SELECT COUNT(*) AS count
            FROM tickers_v4
            WHERE status = 'enabled' AND tradepermission = 'enabled'
        """)
        ticker_count = row["count"]

        # üîπ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
        row = await conn.fetchrow("""
            SELECT COUNT(*) AS count
            FROM indicator_instances_v4
            WHERE enabled = true
        """)
        indicator_count = row["count"]

        # üîπ –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã —Å—Ä–µ–¥–∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
        rows = await conn.fetch("""
            SELECT DISTINCT timeframe
            FROM indicator_instances_v4
            WHERE enabled = true
        """)
        timeframes = sorted(r["timeframe"] for r in rows)

    # üî∏ –í—ã–≤–æ–¥ –≤ –ª–æ–≥
    log.debug(f"üì¶ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∏–∫–µ—Ä–æ–≤: {ticker_count}")
    log.debug(f"üß© –ê–∫—Ç–∏–≤–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤: {indicator_count}")
    log.debug(f"‚è± –¢–∞–π–º—Ñ—Ä–µ–π–º—ã —Å—Ä–µ–¥–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤: {', '.join(timeframes) if timeframes else '‚Äî'}")

# üî∏ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ open_time –ø–æ –∫–∞–∂–¥–æ–º—É —Ç–∞–π–º—Ñ—Ä–µ–π–º—É (24—á –≥–ª—É–±–∏–Ω–∞)
async def analyze_open_times():
    log = logging.getLogger("GAP_CHECKER")

    timeframes = ["m1", "m5", "m15", "h1"]
    step_map = {
        "m1": timedelta(minutes=1),
        "m5": timedelta(minutes=5),
        "m15": timedelta(minutes=15),
        "h1": timedelta(hours=1),
    }

    now = datetime.utcnow().replace(second=0, microsecond=0)

    for tf in timeframes:
        step = step_map[tf]

        # –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–∫–ª—é—á—ë–Ω–Ω—ã–π open_time ‚Äî —ç—Ç–æ now - 2 * step
        end_time = now - 2 * step
        start_time = end_time - timedelta(hours=24)

        open_times = []
        t = start_time

        while t <= end_time:
            open_times.append(t)
            t += step

        if open_times:
            log.info(f"üß™ {tf} ‚Üí {len(open_times)} open_time ({open_times[0]} ‚Äî {open_times[-1]})")
        else:
            log.warning(f"‚ö†Ô∏è {tf} ‚Üí –Ω–µ –Ω–∞–π–¥–µ–Ω–æ open_time")